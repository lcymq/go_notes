# Go并发编程

### 并行与并发 
- 并发（concurrency）：同一时间段内执行多个任务
    - 在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。
- 并行（parallelism）：同一时刻执行多个任务
    - 当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。

### 进程、线程、协程

##### 进程
- 资源分配的最小单位
- 单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。

##### 线程
- 程序执行过程中的最小单元
- 如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。所以线程是依赖于进程的，也称为 「微进程」。
- 一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：
    拖动进度条->画面更新->声音更新。你会明显感到画面和声音和进度条不同步。

##### 进程与线程的区别
1. 进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。
2. 进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。
3. 线程的调度与切换比进程快很多。

- CPU密集型代码(各种循环处理、计算等等)：使用多进程。
- IO密集型代码(文件处理、网络爬虫等)：使用多线程

##### 协程 Coroutine
- 协程是一种用户态的轻量级线程。
- 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

- 协程的好处：
    - 无需线程上下文切换的开销
    - 无需原子操作锁定及同步的开销
    - 方便切换控制流，简化编程模型
高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

- 缺点：
    - 无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
    - 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序

##### 最佳实践
- 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。
- 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

### goroutine
- Go语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，可以根据需要创建成千上万个`goroutine`并发工作。
- `goroutine`是由Go语言的运行时(runtime)调度完成，而线程是由操作系统调度完成。
- Go语言提供`channel`在多个`goroutine`间进行通信。`goroutine`和`channel`是Go语言秉承的CSP(Communicating Sequential Process)并发模式的重要实现基础。

### goroutine使用
- 在调用函数的时候在前面加上`go`关键字，就可以为一个函数创建一个`goroutine`。
- 一个`goroutine`必定对应一个函数，可以创建多个`goroutine`去执行相同的函数。

### 启动单个goroutine
↓ 如果main结束了，hello()也就结束了
```go
func hello() {
	fmt.Println("Hello")
}

func main() {
	go hello()
	fmt.Println("main")
}
```

### goroutine什么时候结束？
- `goroutine`对应的函数结束了，`goroutine`结束了。
- `main`函数执行完了，由`main`函数创建的那些`goroutine`就都结束了。

如何让main函数知道goroutine还没有结束
```go
func f(i int) {
	defer wg.Done()
	time.Sleep(time.Millisecond * time.Duration(rand.Intn(300)))
	fmt.Println(i)
}

var wg sync.WaitGroup

func main() {
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go f(i)
	}
	// 如何知道这10个goroutine都结束了?
	wg.Wait()
}
```

### goroutine与线程
##### 可增长的栈
OS线程(操作系统线程)一般都有固定的栈内存(通常为2MB)，一个`goroutine`的栈在其生命周期开始时只有很小的栈(典型情况下2KB)，`goroutine`的栈不是固定的，他可以按需增大和缩小，`goroutine`的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的`goroutine`也是可以的。

##### goroutine调度
`GMP`是Go语言运行时(runtime)层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。
- `G` - goroutine 协程：里面除了存放本goroutine的信息，还有与所在P的绑定等信息。
- `M` - machine 内核级线程：Go运行时(runtime)对操作系统内核线程的虚拟，M与内核线程一般是一一映射的关系，一个goroutine最终是要放到M上执行的;
- `P` - Processor 协程运行所需资源：P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境(函数指针，堆栈地址及地址边界)，P会对自己管理的goroutine队列做一些调度(比如把占用CPU时间较长的goroutine暂定、运行后续的goroutine等等)，当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会取其他P的队列里抢任务。
- P与M一般是一一对应的。他们的关系是：P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P，把其他的G挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时回收旧的M。
- P的个数是通过`runtime.GOMAXPROCS`设定(最大256)，Go1.5版本之后默认为物理线程数。在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。
- M:N - 把M个goroutine分配给N个操作系统线程去执行。
- goroutine初始栈的大小是2k.

限制最大线程数
```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

var wg sync.WaitGroup

func a() {
	defer wg.Done()
	for i := 0; i < 10; i++ {
		fmt.Println("A:", i)
	}
}

func b() {
	defer wg.Done()
	for i := 0; i < 10; i++ {
		fmt.Println("B:", i)
	}
}

func main() {
	fmt.Println(runtime.NumCPU()) // 线程数
	runtime.GOMAXPROCS(1) // 线程数设置多了反而可能会更慢
	wg.Add(2)
	go a()
	go b()
	wg.Wait()
}
```

